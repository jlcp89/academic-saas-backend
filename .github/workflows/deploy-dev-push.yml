name: Deploy Backend to DEV (Push)

on:
  push:
    branches: [ dev ]

env:
  AWS_REGION: us-east-1

jobs:
  deploy-dev:
    name: Deploy to DEV Environment
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - name: Deploy Django Backend to EC2 (dev)
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST_DEV }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "ğŸš€ Iniciando despliegue del backend..."
            
            # Configurar variables de entorno
            export ENVIRONMENT=dev
            export DATABASE_URL=${{ secrets.DATABASE_URL_DEV }}
            export REDIS_URL=${{ secrets.REDIS_URL_DEV }}
            export SECRET_KEY=${{ secrets.SECRET_KEY_DEV }}
            export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            export AWS_STORAGE_BUCKET_NAME=${{ secrets.AWS_STORAGE_BUCKET_NAME_DEV }}
            
            cd /home/ec2-user
            echo "ğŸ§¹ Limpiando despliegue anterior..."
            sudo rm -rf academic-saas-backend
            
            echo "ğŸ“¥ Clonando repositorio backend..."
            git clone --depth 1 --branch dev https://github.com/jlcp89/academic-saas-backend.git academic-saas-backend
            
            cd academic-saas-backend
            
            echo "ğŸ Configurando Python, PostgreSQL y dependencias..."
            
            # Detect OS and set package manager
            if [ -f /etc/amazon-linux-release ] || [ -f /etc/system-release ]; then
              echo "Detected Amazon Linux 2"
              PKG_MANAGER="yum"
              PYTHON_CMD="python3.8"
              PG_SETUP_CMD="postgresql-setup initdb"
              PG_SERVICE="postgresql"
            elif [ -f /etc/lsb-release ] || [ -f /etc/debian_version ]; then
              echo "Detected Ubuntu/Debian"
              PKG_MANAGER="apt"
              PYTHON_CMD="python3"
              PG_SETUP_CMD=""
              PG_SERVICE="postgresql"
            else
              echo "Unknown OS, defaulting to yum"
              PKG_MANAGER="yum"
              PYTHON_CMD="python3.8"
              PG_SETUP_CMD="postgresql-setup initdb"
              PG_SERVICE="postgresql"
            fi
            
            # Install Python based on OS
            if ! command -v $PYTHON_CMD &> /dev/null; then
              echo "Installing Python..."
              if [ "$PKG_MANAGER" = "yum" ]; then
                sudo yum update -y
                sudo yum install -y amazon-linux-extras
                sudo amazon-linux-extras enable python3.8
                sudo yum install -y python3.8 python3.8-pip
              else
                sudo apt update -y
                sudo apt install -y python3 python3-pip python3-venv
              fi
            fi
            
            # Instalar python3.8 si no estÃ¡ presente
            if ! command -v python3.8 &> /dev/null; then
              sudo yum install -y python38 python38-devel || sudo apt-get install -y python3.8 python3.8-venv python3.8-dev
            fi
            
            # Crear entorno virtual con python3.8
            python3.8 -m venv venv
            source venv/bin/activate
            
            # Instalar dependencias usando el pip del entorno virtual
            ./venv/bin/pip install --upgrade pip
            ./venv/bin/pip install -r requirements.txt
            
            # Usar el python del entorno virtual para todo
            PYTHON_CMD=./venv/bin/python
            
            echo "ğŸ“¦ Instalando dependencias..."
            
            # Install build dependencies based on OS
            if [ "$PKG_MANAGER" = "yum" ]; then
              sudo yum install -y postgresql-devel gcc python3-devel lsof
            else
              sudo apt install -y build-essential python3-dev lsof
            fi
            
            # Verify critical dependencies
            echo "ğŸ” Verifying critical dependencies..."
            $PYTHON_CMD -c "
            import sys
            missing = []
            try:
                import django
                print(f'âœ… Django {django.get_version()}')
            except ImportError:
                missing.append('django')
                
            try:
                import psycopg2
                print('âœ… psycopg2')
            except ImportError:
                missing.append('psycopg2')
                
            try:
                import gunicorn
                print('âœ… gunicorn')
            except ImportError:
                missing.append('gunicorn')
                
            if missing:
                print(f'âŒ Missing: {missing}')
                sys.exit(1)
            "
            
            echo "ğŸ›‘ Limpieza completa de procesos existentes..."
            
            # Stop existing systemd service if it exists
            if sudo systemctl list-unit-files | grep -q academic-backend.service; then
              echo "Stopping existing academic-backend service..."
              sudo systemctl stop academic-backend 2>/dev/null || true
              sudo systemctl disable academic-backend 2>/dev/null || true
            fi
            
            # Remove existing service file to avoid conflicts
            sudo rm -f /etc/systemd/system/academic-backend.service || true
            sudo systemctl daemon-reload || true
            
            # Check if any process is using port 8000 before trying to kill
            echo "ğŸ” Checking puerto 8000..."
            PORT_IN_USE=false
            if sudo lsof -i:8000 -t >/dev/null 2>&1; then
              PORT_IN_USE=true
              echo "Port 8000 is in use, cleaning up..."
            else
              echo "Port 8000 is free"
            fi
            
            # Only try to clean if port is actually in use
            if [ "$PORT_IN_USE" = true ]; then
              # Kill processes using port 8000 with proper error handling
              echo "Cleaning up processes on port 8000..."
              
              # First attempt - graceful termination
              for i in 1 2 3; do
                PIDS=$(sudo lsof -ti:8000 2>/dev/null || echo "")
                if [ -z "$PIDS" ]; then
                  echo "Port 8000 is now free"
                  break
                fi
                
                for PID in $PIDS; do
                  echo "Stopping process $PID (attempt $i)..."
                  sudo kill -TERM $PID 2>/dev/null || true
                done
                sleep 2
              done
              
              # Final attempt - force kill if still running
              PIDS=$(sudo lsof -ti:8000 2>/dev/null || echo "")
              if [ ! -z "$PIDS" ]; then
                echo "Force killing remaining processes..."
                for PID in $PIDS; do
                  sudo kill -KILL $PID 2>/dev/null || true
                done
              fi
            fi
            
            echo "âœ… Limpieza completada"
            
            echo "âš™ï¸ Configurando variables de entorno..."
            
            # Generate a fallback SECRET_KEY if the secret is empty
            SECRET_KEY_VALUE="${{ secrets.SECRET_KEY_DEV }}"
            if [ -z "$SECRET_KEY_VALUE" ]; then
              echo "âš ï¸ SECRET_KEY_DEV not configured, generating temporary key"
              SECRET_KEY_VALUE="dev-temp-key-$(date +%s)-$(openssl rand -hex 32)"
            fi
            
            cat > .env << EOF
            ENVIRONMENT=dev
            DATABASE_URL=postgresql://academic_saas_dev:dev_password_123@localhost:5432/academic_saas_dev
            SECRET_KEY=$SECRET_KEY_VALUE
            DEBUG=True
            ALLOWED_HOSTS=localhost,127.0.0.1,${{ secrets.EC2_HOST_DEV }}
            CORS_ALLOWED_ORIGINS=http://localhost:3000,http://${{ secrets.EC2_HOST_DEV }}:3000,http://${{ secrets.EC2_HOST_DEV }}
            EOF
            
            echo "âœ… Variables de entorno configuradas"
            
            # Debug: Check if .env file was created correctly
            echo "ğŸ” Verificando archivo .env:"
            cat .env
            echo "---"
            
            # Export variables to environment as well
            export ENVIRONMENT=dev
            export DATABASE_URL="postgresql://academic_saas_dev:dev_password_123@localhost:5432/academic_saas_dev"
            export SECRET_KEY="$SECRET_KEY_VALUE"
            export DEBUG=True
            export ALLOWED_HOSTS="localhost,127.0.0.1,${{ secrets.EC2_HOST_DEV }}"
            export CORS_ALLOWED_ORIGINS="http://localhost:3000,http://${{ secrets.EC2_HOST_DEV }}:3000,http://${{ secrets.EC2_HOST_DEV }}"
            
            echo "ğŸ” Verificando variables de entorno:"
            echo "SECRET_KEY length: ${#SECRET_KEY}"
            echo "DATABASE_URL: $DATABASE_URL"
            
            echo "ğŸ”„ Ejecutando migraciones..."
            $PYTHON_CMD manage.py migrate || { 
              echo "\u274c Migration failed, checking database connection:"
              echo 'import os' > check_db.py
              echo 'os.environ.setdefault("DJANGO_SETTINGS_MODULE", "core.settings")' >> check_db.py
              echo 'import django' >> check_db.py
              echo 'django.setup()' >> check_db.py
              echo 'from django.db import connection' >> check_db.py
              echo 'try:' >> check_db.py
              echo '    cursor = connection.cursor()' >> check_db.py
              echo '    cursor.execute("SELECT 1")' >> check_db.py
              echo '    print("âœ… Database connection successful")' >> check_db.py
              echo 'except Exception as e:' >> check_db.py
              echo '    print(f"âŒ Database connection failed: {e}")' >> check_db.py
              $PYTHON_CMD check_db.py
              rm check_db.py
              exit 1; 
            }
            
            echo "ğŸ‘¤ Creando/actualizando superusuario Django..."
            $PYTHON_CMD manage.py shell << 'EOF'
            from apps.users.models import User
            from apps.organizations.models import School
            
            # Crear escuela demo si no existe
            school, created = School.objects.get_or_create(name='Demo School')
            if created:
                print("Escuela demo creada")
            
            # Crear o actualizar superusuario
            admin_user, user_created = User.objects.get_or_create(
                username='admin',
                defaults={
                    'email': 'admin@example.com',
                    'is_superuser': True,
                    'is_staff': True,
                    'role': User.Role.SUPERADMIN,
                    'school': school
                }
            )
            
            if user_created:
                admin_user.set_password('admin123')
                admin_user.save()
                print("âœ… Superusuario creado: admin / admin123")
            else:
                # Usuario existe, verificar y actualizar role si es necesario
                if not admin_user.role or admin_user.role == '':
                    admin_user.role = User.Role.SUPERADMIN
                    admin_user.is_superuser = True
                    admin_user.is_staff = True
                    admin_user.save()
                    print("âœ… Role de admin actualizado a SUPERADMIN")
                else:
                    print("âœ… Superusuario ya existe con role correcto: admin / admin123")
            EOF
            
            echo "ğŸ“ Recolectando archivos estÃ¡ticos..."
            $PYTHON_CMD manage.py collectstatic --noinput || { echo "Collectstatic failed"; exit 1; }
            
            echo "ğŸš€ Configurando systemd service para Django..."
            
            # Test Django configuration first
            echo "ğŸ” Verificando configuraciÃ³n de Django..."
            $PYTHON_CMD manage.py check || { 
              echo "âŒ Django check failed"
              $PYTHON_CMD manage.py check --deploy || true
              exit 1
            }
            
            # Get absolute path for Python and verify
            PYTHON_PATH=$(which $PYTHON_CMD)
            echo "Using Python at: $PYTHON_PATH"
            if [ ! -f "$PYTHON_PATH" ]; then
              echo "âŒ Python path not found: $PYTHON_PATH"
              exit 1
            fi
            
            # Verify gunicorn is available
            if ! $PYTHON_PATH -m gunicorn --version >/dev/null 2>&1; then
              echo "âŒ Gunicorn not available with $PYTHON_PATH"
              exit 1
            fi
            
            echo "âœ… Python and Gunicorn verified"
            echo "ğŸ“ Creating systemd service file..."
            
            # Create systemd service for backend
            sudo tee /etc/systemd/system/academic-backend.service <<EOF
            [Unit]
            Description=Academic SaaS Backend
            After=network.target postgresql.service
            Requires=postgresql.service
            
            [Service]
            Type=simple
            User=ec2-user
            WorkingDirectory=/home/ec2-user/academic-saas-backend
            Environment="ENVIRONMENT=dev"
            Environment="DATABASE_URL=postgresql://academic_saas_dev:dev_password_123@localhost:5432/academic_saas_dev"
            Environment="SECRET_KEY=$SECRET_KEY_VALUE"
            Environment="DEBUG=True"
            Environment="ALLOWED_HOSTS=localhost,127.0.0.1,${{ secrets.EC2_HOST_DEV }}"
            Environment="CORS_ALLOWED_ORIGINS=http://localhost:3000,http://${{ secrets.EC2_HOST_DEV }}:3000,http://${{ secrets.EC2_HOST_DEV }}"
            ExecStart=$PYTHON_PATH -m gunicorn --bind 127.0.0.1:8000 --workers 2 core.wsgi:application
            Restart=always
            RestartSec=10
            StandardOutput=journal
            StandardError=journal
            
            [Install]
            WantedBy=multi-user.target
            EOF
            
            # Verify service file was created correctly
            echo "ğŸ” Verificando archivo de servicio..."
            if [ ! -f /etc/systemd/system/academic-backend.service ]; then
              echo "âŒ Service file not created"
              exit 1
            fi
            
            # Check service file syntax
            echo "ğŸ“‹ Contenido del archivo de servicio:"
            cat /etc/systemd/system/academic-backend.service
            
            # Start backend service
            echo "ğŸš€ Iniciando servicio backend..."
            sudo systemctl daemon-reload
            sudo systemctl enable academic-backend
            sudo systemctl restart academic-backend
            
            # Wait for backend to start
            echo "â³ Esperando que el backend estÃ© listo..."
            sleep 15
            
            # Verify backend service
            if sudo systemctl is-active --quiet academic-backend; then
              echo "âœ… Backend service is running!"
              
              # Check if backend responds
              for i in {1..6}; do
                if curl -f http://localhost:8000/admin/login/ > /dev/null 2>&1; then
                  echo "âœ… Backend responding on port 8000"
                  break
                else
                  echo "â³ Waiting for backend to respond... ($i/6)"
                  sleep 5
                fi
              done
            else
              echo "âŒ Backend service failed to start"
              sudo journalctl -u academic-backend -n 50
              exit 1
            fi
            
            echo "ğŸŒ Configurando Nginx..."
            # Install nginx if not present
            if ! command -v nginx &> /dev/null; then
              echo "Installing nginx..."
              if [ "$PKG_MANAGER" = "yum" ]; then
                sudo amazon-linux-extras install -y nginx1
              else
                sudo apt install -y nginx
              fi
            fi
            
            # Stop nginx if running
            sudo systemctl stop nginx || true
            
            # Create nginx directories if they don't exist
            sudo mkdir -p /etc/nginx
            sudo mkdir -p /var/log/nginx
            
            # Remove any conflicting configurations
            sudo rm -f /etc/nginx/conf.d/academic-saas-frontend.conf || true
            sudo rm -f /etc/nginx/conf.d/default.conf || true
            
            # Validate nginx config file exists and has correct CSS routing
            if [ ! -f "nginx-dev.conf" ]; then
              echo "âŒ ERROR: nginx-dev.conf not found in repository!"
              exit 1
            fi
            
            # Check if nginx config has the critical /_next/ location block for CSS
            if ! grep -q "location /_next/" nginx-dev.conf; then
              echo "âŒ ERROR: nginx-dev.conf missing critical /_next/ location block for CSS files!"
              echo "This will cause frontend styles to break!"
              exit 1
            fi
            
            # Check if config does NOT have the problematic regex location that breaks CSS
            if grep -q "location ~.*\\\.(css|js|map" nginx-dev.conf; then
              echo "âŒ ERROR: nginx-dev.conf contains problematic regex location block!"
              echo "This will cause CSS routing conflicts!"
              exit 1
            fi
            
            echo "âœ… Nginx config validation passed"
            
            # Copy nginx development configuration
            sudo cp nginx-dev.conf /etc/nginx/nginx.conf
            
            # Test nginx configuration syntax
            sudo nginx -t || { echo "âŒ Nginx config syntax test failed"; cat /var/log/nginx/error.log || true; exit 1; }
            
            # Start nginx
            sudo systemctl enable nginx
            sudo systemctl restart nginx
            
            echo "â³ Esperando que Nginx estÃ© listo..."
            sleep 5
            
            echo "ğŸ” Verificando salud del servicio completo..."
            
            # Final verification through nginx
            for i in {1..5}; do
              if curl -f http://localhost/admin/login/ > /dev/null 2>&1; then
                echo "âœ… Backend con Nginx desplegado exitosamente!"
                
                # CRITICAL: Verify CSS routing is working
                echo "ğŸ¨ Verificando routing de archivos CSS..."
                if curl -f http://localhost/_next/ > /dev/null 2>&1; then
                  echo "âœ… CSS routing funcionando correctamente"
                else
                  echo "âš ï¸ WARNING: CSS routing might have issues"
                fi
                
                echo "ğŸŒ URL: http://${{ secrets.EC2_HOST_DEV }}"
                echo "ğŸ”§ Admin: http://${{ secrets.EC2_HOST_DEV }}/admin"
                echo "ğŸ“š API Docs: http://${{ secrets.EC2_HOST_DEV }}/api/docs/"
                echo "ğŸ¨ Styles: CSS routing validated"
                exit 0
              else
                echo "Intento $i/5: Esperando respuesta del servidor..."
                if [ $i -eq 5 ]; then
                  echo "Verificando logs del backend:"
                  sudo journalctl -u academic-backend -n 20 || echo "No hay logs disponibles"
                  echo "Verificando procesos:"
                  sudo systemctl status academic-backend || echo "Servicio no activo"
                fi
                sleep 5
              fi
            done
            
            echo "âŒ Error: El backend no responde despuÃ©s de varios intentos"
            echo "Estado del servicio backend:"
            sudo systemctl status academic-backend || echo "Servicio no disponible"
            echo "Logs del backend:"
            sudo journalctl -u academic-backend -n 50 || echo "No hay logs disponibles"
            exit 1

      - name: Verify deployment
        run: |
          echo "ğŸ” Verificando despliegue del backend con Nginx..."
          sleep 15
          
          # Try multiple times with more detailed output
          for i in {1..3}; do
            echo "Intento de verificaciÃ³n $i/3..."
            if curl -f -v http://${{ secrets.EC2_HOST_DEV }}/admin/login/ 2>&1; then
              echo "âœ… VerificaciÃ³n del backend con Nginx completada exitosamente!"
              exit 0
            else
              echo "âŒ Intento $i fallÃ³, esperando antes del siguiente intento..."
              sleep 10
            fi
          done
          
          echo "âŒ VerificaciÃ³n fallÃ³ despuÃ©s de 3 intentos"
          exit 1

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "ğŸ‰ Backend deployment successful!"
            echo "âœ… Application is live and healthy"
            echo "ğŸŒ API URL: http://${{ secrets.EC2_HOST_DEV }}:8000"
            echo "ğŸ”§ Admin URL: http://${{ secrets.EC2_HOST_DEV }}:8000/admin"
          else
            echo "âŒ Backend deployment failed!"
            echo "ğŸ” Check the logs above for more details"
          fi 